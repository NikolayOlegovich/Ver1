const m="social-capital-db-v1";function p(){return new Promise((n,s)=>{const o=indexedDB.open(m,2);o.onupgradeneeded=()=>{const r=o.result;if(!r.objectStoreNames.contains("contacts")){const t=r.createObjectStore("contacts",{keyPath:"id"});t.createIndex("lastName","lastName"),t.createIndex("organization","organization")}if(r.objectStoreNames.contains("profiles")||r.createObjectStore("profiles",{keyPath:"id"}).createIndex("contactId","contactId"),!r.objectStoreNames.contains("interactions")){const t=r.createObjectStore("interactions",{keyPath:"id"});t.createIndex("contactId_date",["contactId","date"]),t.createIndex("date","date")}if(!r.objectStoreNames.contains("reminders")){const t=r.createObjectStore("reminders",{keyPath:"id"});t.createIndex("contactId","contactId"),t.createIndex("dueAt","dueAt")}r.objectStoreNames.contains("scores")||r.createObjectStore("scores",{keyPath:"contactId"})},o.onsuccess=()=>n(o.result),o.onerror=()=>s(o.error)})}async function a(n,s,o){const r=await p();return new Promise((t,e)=>{const c=r.transaction(n,s);o(r,c).then(t).catch(e)})}const f={async getById(n){return a(["contacts"],"readonly",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("contacts").get(n);e.onsuccess=()=>r(e.result??null),e.onerror=()=>t(e.error)}))},async upsert(n){return n.updatedAt=n.updatedAt||new Date().toISOString(),a(["contacts"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("contacts").put(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))},async searchByNameOrg(n,s=20){const o=(n||"").toLowerCase();return a(["contacts"],"readonly",async(r,t)=>new Promise((e,c)=>{const u=[],i=t.objectStore("contacts").openCursor();i.onsuccess=()=>{const l=i.result;if(!l){e(u);return}const d=l.value,y=`${d.firstName} ${d.lastName} ${d.organization??""}`.toLowerCase();if((o===""||y.includes(o))&&u.push(d),u.length>=s){e(u);return}l.continue()},i.onerror=()=>c(i.error)}))}},w={async listByContact(n){return a(["profiles"],"readonly",async(s,o)=>new Promise((r,t)=>{const c=o.objectStore("profiles").index("contactId").getAll(IDBKeyRange.only(n));c.onsuccess=()=>r(c.result??[]),c.onerror=()=>t(c.error)}))},async upsert(n){return a(["profiles"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("profiles").put(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))},async remove(n){return a(["profiles"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("profiles").delete(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))}},S={async listByContact(n,s){const o=s?.limit??20,r=s?.offset??0;return a(["interactions"],"readonly",async(t,e)=>new Promise((c,u)=>{const i=[],d=e.objectStore("interactions").index("contactId_date").openCursor(IDBKeyRange.bound([n,""],[n,"ï¿¿"]),"prev");let y=0;d.onsuccess=()=>{const b=d.result;if(!b){c(i);return}if(y<r){y++,b.continue();return}if(i.push(b.value),i.length>=o){c(i);return}b.continue()},d.onerror=()=>u(d.error)}))},async create(n){return a(["interactions"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("interactions").add(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))},async update(n){return a(["interactions"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("interactions").put(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))}},j={async listByContact(n){return a(["reminders"],"readonly",async(s,o)=>new Promise((r,t)=>{const c=o.objectStore("reminders").index("contactId").getAll(IDBKeyRange.only(n));c.onsuccess=()=>r(c.result??[]),c.onerror=()=>t(c.error)}))},async upsert(n){return a(["reminders"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("reminders").put(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))},async markDone(n){const s=await a(["reminders"],"readonly",async(o,r)=>new Promise((t,e)=>{const c=r.objectStore("reminders").get(n);c.onsuccess=()=>t(c.result??null),c.onerror=()=>e(c.error)}));s&&(s.done=!0,await this.upsert(s))}},I={async get(n){return a(["scores"],"readonly",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("scores").get(n);e.onsuccess=()=>r(e.result??null),e.onerror=()=>t(e.error)}))},async upsert(n){return a(["scores"],"readwrite",async(s,o)=>new Promise((r,t)=>{const e=o.objectStore("scores").put(n);e.onsuccess=()=>r(),e.onerror=()=>t(e.error)}))}};function P(){return{contacts:f,profiles:w,interactions:S,reminders:j,scores:I}}export{P as createDexieStorage};
